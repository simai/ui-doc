---
extends: _core._layouts.documentation
section: content
title: 1.4 Кэширование и ускорение загрузки
description: 1.4 Кэширование и ускорение загрузки
---

# 1.4 Кэширование и ускорение загрузки

*SFLoaderPlugin** реализует систему кэширования, чтобы ускорить повторные загрузки компонентов. Это позволяет:

* **не загружать одни и те же плагины повторно**;
* сократить количество сетевых запросов;
* использовать уже сгенерированные шаблоны и ассеты.

Кэш хранится в **localStorage** браузера.

Используются ключи с уникальным идентификатором страницы (`pageHash`), рассчитанным по URL (обычно md5 от
`window.location.pathname`, первые 16 символов).

Это позволяет разделять кэш между разными страницами и не загружать лишние данные.

## Что кэшируется

Загрузчик сохраняет данные в **localStorage**, используя хеш страницы (по URL). Кэш включает:

### Список загруженных плагинов

* Ключ: `SF_PLUGIN_LIST-<pageHash>`
* Содержит имена успешно подключенных JS/CSS компонентов.

### Шаблоны Smart-компонентов

* Ключ: `SF_SMART_LIST-<pageHash>`
* Содержит сериализованные HTML-шаблоны (если используются).

### Список недоступных плагинов и их файлов

* Ключ: `SF_MISSING_PLUGINS`
* Временный список, предотвращающий повторные попытки загрузки.


## Как создается `Хеш`

Для идентификации страницы используется хеш, создаваемый на основе URL:

```js
const pageHash = md5(window.location.pathname).slice(0, 16);
```

Он используется как часть ключа в `localStorage` и имени файлов (например: `bundle-<pageHash>-<hash>.js`).

## Как работает кэширование

* При первой загрузке страницы — создается и сохраняется кэш.
* При повторном визите на ту же страницу:
    * загрузчик проверяет наличие `SF_PLUGIN_LIST-<hash>`;
    * если он есть — не запрашивает ассеты заново;
    * если нет — загружает заново и обновляет кэш.

## Сжатие данных (compressToUTF16)

* Все данные **сжимаются перед сохранением** с помощью метода **`LZString.compressToUTF16()`**
* Уменьшает объём хранимой информации;
* Повышает производительность чтения/записи;
* Укладывается в лимиты хранилища браузера (5–10 MB).


### Пример

```js
const raw = JSON.stringify({ modal: true, core: true });
const compressed = LZString.compressToUTF16(raw);
localStorage.setItem('SF\_PLUGIN\_LIST-abc123', compressed);

// Для чтения
const data = JSON.parse(LZString.decompressFromUTF16(localStorage.getItem('SF_PLUGIN_LIST-abc123')));
```

Этот метод **безопасен для хранения в localStorage**, так как кодирует только допустимые UTF-16 символы (в отличие от
обычного Base64).

Используется как для списка подключенных плагинов, так и для шаблонов Smart-компонентов.

* **SFLoaderPlugin** не просто сохраняет кэш в **localStorage**, но и **оптимизирует его размер** через
  `compressToUTF16`.
* Это делает загрузку не только быстрой, но и экономичной по памяти.
* Пользователь видит мгновенный интерфейс даже без запроса к серверу, если шаблоны и плагины уже были ранее загружены.

## Когда используется кэш

* При загрузке страницы загрузчик проверяет наличие кэша по `pageHash`.
* Если он найден:
    * Недостающие файлы плагинов не загружаются повторно;
    * Шаблоны смарт-компонентов не запрашиваются с сервера;
* Если не найден — данные загружаются и кэшируются заново.

## Очистка кэша

Для принудительной очистки кэша можно:

* В URL страницы добавить `?loader_clear=Y`;
* Вызвать метод вручную:

```js
SF.Loader.clearCache();
```
